<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Marble Solitaire</title>
<style>
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --cell-size: min(11vw, 11vh, 70px);
    --marble-size: calc(var(--cell-size) * 0.72);
    --board-pad: calc(var(--cell-size) * 0.45);
    --hole-size: calc(var(--cell-size) * 0.62);
  }

  body {
    min-height: 100dvh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: linear-gradient(135deg, #0f0c29 0%, #1a1a3e 30%, #24243e 60%, #0f0c29 100%);
    overflow: hidden;
    color: #e0dcd0;
    user-select: none;
    -webkit-user-select: none;
  }

  /* Ambient floating particles */
  .ambient {
    position: fixed; inset: 0; pointer-events: none; z-index: 0; overflow: hidden;
  }
  .ambient span {
    position: absolute;
    width: 3px; height: 3px;
    background: rgba(255,255,255,0.15);
    border-radius: 50%;
    animation: float-up linear infinite;
  }
  @keyframes float-up {
    0% { transform: translateY(100vh) scale(0); opacity: 0; }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { transform: translateY(-10vh) scale(1); opacity: 0; }
  }

  /* Header */
  .header {
    text-align: center;
    margin-bottom: 18px;
    z-index: 2;
    position: relative;
  }
  .header h1 {
    font-size: clamp(22px, 4vw, 34px);
    font-weight: 300;
    letter-spacing: 6px;
    text-transform: uppercase;
    background: linear-gradient(135deg, #d4af37, #f5e6a3, #d4af37);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: none;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
  }

  /* Stats bar */
  .stats {
    display: flex;
    gap: 24px;
    justify-content: center;
    margin-bottom: 16px;
    z-index: 2;
    position: relative;
    flex-wrap: wrap;
  }
  .stat {
    text-align: center;
    min-width: 70px;
  }
  .stat-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: #8888aa;
    margin-bottom: 2px;
  }
  .stat-value {
    font-size: 22px;
    font-weight: 200;
    color: #d4af37;
  }

  /* Board wrapper */
  .board-wrapper {
    position: relative;
    z-index: 2;
    perspective: 800px;
  }
  .board {
    display: grid;
    grid-template-columns: repeat(7, var(--cell-size));
    grid-template-rows: repeat(7, var(--cell-size));
    gap: 0;
    padding: var(--board-pad);
    border-radius: 18px;
    position: relative;
    /* Wood texture */
    background:
      repeating-linear-gradient(
        90deg,
        transparent 0px,
        rgba(0,0,0,0.03) 1px,
        transparent 2px,
        transparent 18px
      ),
      repeating-linear-gradient(
        90deg,
        transparent 0px,
        rgba(255,255,255,0.02) 0.5px,
        transparent 1px,
        transparent 11px
      ),
      linear-gradient(
        180deg,
        #6b4226 0%, #7a5033 15%, #6b4226 30%, #5a3520 50%,
        #6b4226 65%, #7a5033 80%, #6b4226 100%
      );
    box-shadow:
      0 2px 4px rgba(0,0,0,0.3),
      0 8px 20px rgba(0,0,0,0.4),
      0 20px 50px rgba(0,0,0,0.5),
      inset 0 1px 0 rgba(255,255,255,0.1),
      inset 0 -1px 0 rgba(0,0,0,0.2);
    transform: rotateX(2deg);
    transition: transform 0.6s ease;
  }
  .board::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 18px;
    background:
      repeating-linear-gradient(
        87deg,
        transparent 0px,
        rgba(139,90,43,0.15) 3px,
        transparent 4px,
        transparent 25px
      );
    pointer-events: none;
  }
  .board::after {
    content: '';
    position: absolute;
    inset: 4px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.05);
    pointer-events: none;
  }

  /* Cells */
  .cell {
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  /* Holes */
  .hole {
    width: var(--hole-size);
    height: var(--hole-size);
    border-radius: 50%;
    position: relative;
    background: radial-gradient(circle at 40% 35%,
      #3d2510 0%, #2a1a0c 60%, #1a0f06 100%
    );
    box-shadow:
      inset 0 3px 8px rgba(0,0,0,0.8),
      inset 0 1px 3px rgba(0,0,0,0.6),
      0 1px 0 rgba(255,255,255,0.08);
  }
  .hole.valid-target {
    animation: pulse-hole 1.2s ease-in-out infinite;
  }
  .hole.valid-target::after {
    content: '';
    position: absolute;
    inset: 3px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(100,220,180,0.35) 0%, transparent 70%);
    animation: pulse-glow 1.2s ease-in-out infinite;
  }
  @keyframes pulse-hole {
    0%, 100% { box-shadow: inset 0 3px 8px rgba(0,0,0,0.8), inset 0 1px 3px rgba(0,0,0,0.6), 0 1px 0 rgba(255,255,255,0.08), 0 0 6px rgba(100,220,180,0.2); }
    50% { box-shadow: inset 0 3px 8px rgba(0,0,0,0.8), inset 0 1px 3px rgba(0,0,0,0.6), 0 1px 0 rgba(255,255,255,0.08), 0 0 14px rgba(100,220,180,0.45); }
  }
  @keyframes pulse-glow {
    0%, 100% { opacity: 0.4; }
    50% { opacity: 1; }
  }

  /* Marble */
  .marble {
    width: var(--marble-size);
    height: var(--marble-size);
    border-radius: 50%;
    position: absolute;
    cursor: pointer;
    z-index: 3;
    transition: filter 0.2s ease, transform 0.2s ease;
    /* Glass marble */
    background:
      radial-gradient(circle at 30% 25%, rgba(255,255,255,0.85) 0%, rgba(255,255,255,0.15) 15%, transparent 40%),
      radial-gradient(circle at 65% 70%, rgba(0,80,80,0.4) 0%, transparent 40%),
      radial-gradient(circle at 50% 50%, #1a8a7a 0%, #0d6b5e 30%, #074a42 60%, #032e2a 85%, #011a18 100%);
    box-shadow:
      0 3px 8px rgba(0,0,0,0.5),
      0 1px 3px rgba(0,0,0,0.4),
      inset 0 -4px 8px rgba(0,0,0,0.3),
      inset 0 2px 4px rgba(255,255,255,0.15);
  }
  .marble::before {
    content: '';
    position: absolute;
    width: 35%;
    height: 20%;
    top: 14%;
    left: 22%;
    border-radius: 50%;
    background: rgba(255,255,255,0.5);
    filter: blur(2px);
    transform: rotate(-25deg);
  }
  .marble::after {
    content: '';
    position: absolute;
    width: 12%;
    height: 8%;
    top: 38%;
    left: 58%;
    border-radius: 50%;
    background: rgba(255,255,255,0.35);
    filter: blur(1px);
  }
  .marble:hover {
    filter: brightness(1.12);
    transform: scale(1.04);
  }
  .marble.selected {
    transform: scale(1.12) translateY(-4px);
    box-shadow:
      0 8px 20px rgba(100,220,180,0.35),
      0 4px 10px rgba(0,0,0,0.4),
      inset 0 -4px 8px rgba(0,0,0,0.3),
      inset 0 2px 4px rgba(255,255,255,0.15),
      0 0 20px rgba(100,220,180,0.3);
    filter: brightness(1.2);
  }

  /* Marble entrance animation */
  .marble.entering {
    animation: marble-enter 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) both;
  }
  @keyframes marble-enter {
    0% { transform: scale(0) translateY(-30px); opacity: 0; }
    100% { transform: scale(1) translateY(0); opacity: 1; }
  }

  /* Marble removal animation */
  .marble.removing {
    animation: marble-remove 0.4s ease-in forwards;
    pointer-events: none;
  }
  @keyframes marble-remove {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.2); opacity: 0.6; }
    100% { transform: scale(0); opacity: 0; }
  }

  /* Jump animation marble (the flying one) */
  .marble.jumping {
    z-index: 10;
    pointer-events: none;
  }

  /* Particle burst */
  .particle {
    position: absolute;
    width: 5px;
    height: 5px;
    border-radius: 50%;
    pointer-events: none;
    z-index: 5;
  }
  @keyframes particle-fly {
    0% { transform: translate(0,0) scale(1); opacity: 1; }
    100% { opacity: 0; }
  }

  /* Controls */
  .controls {
    display: flex;
    gap: 12px;
    margin-top: 18px;
    z-index: 2;
    position: relative;
    flex-wrap: wrap;
    justify-content: center;
  }
  .btn {
    padding: 10px 22px;
    border: 1px solid rgba(212,175,55,0.3);
    background: rgba(255,255,255,0.04);
    color: #c0b896;
    border-radius: 8px;
    font-size: 13px;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.25s ease;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    font-family: inherit;
  }
  .btn:hover {
    background: rgba(212,175,55,0.12);
    border-color: rgba(212,175,55,0.5);
    color: #d4af37;
  }
  .btn:active {
    transform: scale(0.96);
  }
  .btn:disabled {
    opacity: 0.3;
    cursor: default;
    pointer-events: none;
  }
  .btn.icon-btn {
    padding: 10px 14px;
    font-size: 16px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .btn.icon-btn .lbl {
    font-size: 11px;
  }

  /* Modal overlay */
  .modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease;
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
  }
  .modal-overlay.active {
    opacity: 1;
    pointer-events: all;
  }
  .modal {
    background: linear-gradient(145deg, #2a2a4a, #1a1a3a);
    border: 1px solid rgba(212,175,55,0.25);
    border-radius: 16px;
    padding: 40px;
    text-align: center;
    max-width: 360px;
    width: 90%;
    transform: scale(0.8);
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  .modal-overlay.active .modal {
    transform: scale(1);
  }
  .modal h2 {
    font-weight: 300;
    font-size: 28px;
    margin-bottom: 8px;
    background: linear-gradient(135deg, #d4af37, #f5e6a3);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .modal p {
    color: #9999bb;
    margin-bottom: 24px;
    font-size: 15px;
    line-height: 1.5;
  }
  .modal .btn {
    margin: 0 auto;
  }

  /* Confetti */
  .confetti-piece {
    position: fixed;
    width: 8px;
    height: 12px;
    z-index: 99;
    pointer-events: none;
    animation: confetti-fall linear forwards;
  }
  @keyframes confetti-fall {
    0% { opacity: 1; }
    90% { opacity: 1; }
    100% { transform: translateY(105vh) rotate(720deg); opacity: 0; }
  }

  /* Marbles remaining label */
  .remaining {
    font-size: 11px;
    color: #666688;
    letter-spacing: 1px;
    margin-top: 6px;
    text-align: center;
    z-index: 2;
    position: relative;
  }

  /* Responsive */
  @media (max-width: 520px) {
    :root { --cell-size: 12.5vw; }
    .stats { gap: 16px; }
    .controls { gap: 8px; }
    .btn { padding: 8px 14px; font-size: 11px; }
    .modal { padding: 28px; }
  }
</style>
</head>
<body>

<div class="ambient" id="ambient"></div>

<div class="header">
  <h1>Marble Solitaire</h1>
</div>

<div class="stats">
  <div class="stat">
    <div class="stat-label">Moves</div>
    <div class="stat-value" id="moves">0</div>
  </div>
  <div class="stat">
    <div class="stat-label">Remaining</div>
    <div class="stat-value" id="remaining">32</div>
  </div>
  <div class="stat">
    <div class="stat-label">Best</div>
    <div class="stat-value" id="best">-</div>
  </div>
</div>

<div class="board-wrapper">
  <div class="board" id="board"></div>
</div>

<div class="remaining" id="remaining-label">32 marbles on the board</div>

<div class="controls">
  <button class="btn" id="btn-undo" disabled>Undo</button>
  <button class="btn" id="btn-restart">Restart</button>
  <button class="btn icon-btn" id="btn-sound">
    <span id="sound-icon">&#x1f50a;</span>
    <span class="lbl" id="sound-lbl">On</span>
  </button>
</div>

<div class="modal-overlay" id="modal">
  <div class="modal">
    <h2 id="modal-title">Victory!</h2>
    <p id="modal-msg">Congratulations!</p>
    <button class="btn" id="modal-btn">Play Again</button>
  </div>
</div>

<script>
(() => {
  'use strict';

  // --- Board Definition ---
  const BOARD_MASK = [
    [0,0,1,1,1,0,0],
    [0,0,1,1,1,0,0],
    [1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1],
    [0,0,1,1,1,0,0],
    [0,0,1,1,1,0,0],
  ];
  const CENTER = { r: 3, c: 3 };
  const DIRS = [[0,1],[0,-1],[1,0],[-1,0]];

  // --- State ---
  let board = [];      // 7x7: 0=invalid, 1=marble, 2=empty
  let selected = null; // {r, c}
  let moveCount = 0;
  let history = [];    // [{from, over, to, board snapshot}]
  let animating = false;
  let soundEnabled = true;
  let bestScore = loadBest();

  // --- Audio ---
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;

  function ensureAudio() {
    if (!audioCtx) {
      try { audioCtx = new AudioCtx(); } catch(e) { /* no audio */ }
    }
  }

  function playSound(type) {
    if (!soundEnabled || !audioCtx) return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      if (type === 'jump') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(520, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(780, audioCtx.currentTime + 0.08);
        osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.15);
        gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.2);
      } else if (type === 'remove') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(900, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.25);
        gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.3);
      } else if (type === 'select') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(660, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.06, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.1);
      } else if (type === 'win') {
        [0, 0.12, 0.24, 0.36, 0.48].forEach((t, i) => {
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.connect(g); g.connect(audioCtx.destination);
          o.type = 'sine';
          o.frequency.setValueAtTime([523, 659, 784, 1047, 1319][i], audioCtx.currentTime + t);
          g.gain.setValueAtTime(0.1, audioCtx.currentTime + t);
          g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + t + 0.2);
          o.start(audioCtx.currentTime + t);
          o.stop(audioCtx.currentTime + t + 0.2);
        });
      } else if (type === 'lose') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.06, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.5);
      }
    } catch(e) {}
  }

  // --- Local Storage ---
  function loadBest() {
    try { const v = localStorage.getItem('marble-sol-best'); return v ? parseInt(v) : null; } catch(e) { return null; }
  }
  function saveBest(n) {
    try { localStorage.setItem('marble-sol-best', n); } catch(e) {}
  }

  // --- Board Init ---
  function initBoard() {
    board = [];
    for (let r = 0; r < 7; r++) {
      board[r] = [];
      for (let c = 0; c < 7; c++) {
        if (!BOARD_MASK[r][c]) board[r][c] = 0;
        else if (r === CENTER.r && c === CENTER.c) board[r][c] = 2;
        else board[r][c] = 1;
      }
    }
    selected = null;
    moveCount = 0;
    history = [];
    animating = false;
    updateStats();
  }

  // --- Rendering ---
  const boardEl = document.getElementById('board');

  function renderBoard(entrance = false) {
    boardEl.innerHTML = '';
    let delay = 0;
    for (let r = 0; r < 7; r++) {
      for (let c = 0; c < 7; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.r = r;
        cell.dataset.c = c;

        if (board[r][c] === 0) {
          // Invalid cell - empty space
        } else {
          // Valid position - add hole
          const hole = document.createElement('div');
          hole.className = 'hole';
          hole.dataset.r = r;
          hole.dataset.c = c;
          cell.appendChild(hole);

          if (board[r][c] === 1) {
            const marble = document.createElement('div');
            marble.className = 'marble';
            if (entrance) {
              marble.classList.add('entering');
              marble.style.animationDelay = delay + 'ms';
              delay += 25;
            }
            marble.dataset.r = r;
            marble.dataset.c = c;
            if (selected && selected.r === r && selected.c === c) {
              marble.classList.add('selected');
            }
            cell.appendChild(marble);
          }
        }
        boardEl.appendChild(cell);
      }
    }
    highlightValidTargets();
  }

  function highlightValidTargets() {
    // Remove old highlights
    document.querySelectorAll('.hole.valid-target').forEach(h => h.classList.remove('valid-target'));
    if (!selected) return;
    const moves = getValidMoves(selected.r, selected.c);
    moves.forEach(m => {
      const hole = boardEl.querySelector(`.hole[data-r="${m.to.r}"][data-c="${m.to.c}"]`);
      if (hole) hole.classList.add('valid-target');
    });
  }

  // --- Game Logic ---
  function isValid(r, c) {
    return r >= 0 && r < 7 && c >= 0 && c < 7 && BOARD_MASK[r][c];
  }

  function getValidMoves(r, c) {
    const moves = [];
    if (board[r][c] !== 1) return moves;
    for (const [dr, dc] of DIRS) {
      const mr = r + dr, mc = c + dc;
      const tr = r + 2*dr, tc = c + 2*dc;
      if (isValid(tr, tc) && board[mr][mc] === 1 && board[tr][tc] === 2) {
        moves.push({ from: {r, c}, over: {r: mr, c: mc}, to: {r: tr, c: tc} });
      }
    }
    return moves;
  }

  function hasAnyMoves() {
    for (let r = 0; r < 7; r++)
      for (let c = 0; c < 7; c++)
        if (board[r][c] === 1 && getValidMoves(r, c).length > 0)
          return true;
    return false;
  }

  function countMarbles() {
    let n = 0;
    for (let r = 0; r < 7; r++)
      for (let c = 0; c < 7; c++)
        if (board[r][c] === 1) n++;
    return n;
  }

  function checkWin() {
    const n = countMarbles();
    if (n === 1 && board[CENTER.r][CENTER.c] === 1) return 'perfect';
    if (n === 1) return 'win';
    if (!hasAnyMoves()) return 'lose';
    return null;
  }

  // --- Animations ---
  function getCellCenter(r, c) {
    const cell = boardEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
    if (!cell) return { x: 0, y: 0 };
    const rect = cell.getBoundingClientRect();
    const boardRect = boardEl.getBoundingClientRect();
    return {
      x: rect.left + rect.width / 2 - boardRect.left,
      y: rect.top + rect.height / 2 - boardRect.top,
    };
  }

  function spawnParticles(r, c) {
    const pos = getCellCenter(r, c);
    const boardRect = boardEl.getBoundingClientRect();
    const colors = ['#64dcb4', '#d4af37', '#4ecdc4', '#fff', '#ff6b6b', '#c7f464'];
    for (let i = 0; i < 10; i++) {
      const p = document.createElement('div');
      p.className = 'particle';
      const angle = (Math.PI * 2 * i) / 10 + Math.random() * 0.5;
      const dist = 25 + Math.random() * 35;
      const dx = Math.cos(angle) * dist;
      const dy = Math.sin(angle) * dist;
      p.style.background = colors[Math.floor(Math.random() * colors.length)];
      p.style.left = (boardRect.left + pos.x - 2.5) + 'px';
      p.style.top = (boardRect.top + pos.y - 2.5) + 'px';
      p.style.animation = `particle-fly 0.5s ease-out forwards`;
      p.style.setProperty('--dx', dx + 'px');
      p.style.setProperty('--dy', dy + 'px');

      // Use per-element keyframe via Web Animations API
      document.body.appendChild(p);
      p.animate([
        { transform: 'translate(0, 0) scale(1)', opacity: 1 },
        { transform: `translate(${dx}px, ${dy}px) scale(0)`, opacity: 0 },
      ], { duration: 450, easing: 'ease-out', fill: 'forwards' });
      setTimeout(() => p.remove(), 500);
    }
  }

  async function animateJump(from, to) {
    return new Promise(resolve => {
      const fromPos = getCellCenter(from.r, from.c);
      const toPos = getCellCenter(to.r, to.c);

      // Get the marble element
      const marbleEl = boardEl.querySelector(`.marble[data-r="${from.r}"][data-c="${from.c}"]`);
      if (!marbleEl) { resolve(); return; }

      marbleEl.classList.add('jumping');
      marbleEl.classList.remove('selected');

      const dx = toPos.x - fromPos.x;
      const dy = toPos.y - fromPos.y;
      const duration = 280;

      const start = performance.now();
      function tick(now) {
        const t = Math.min((now - start) / duration, 1);
        // Ease: cubic out
        const ease = 1 - Math.pow(1 - t, 3);
        const x = dx * ease;
        const y = dy * ease;
        // Arc height
        const arc = -Math.sin(t * Math.PI) * 28;
        marbleEl.style.transform = `translate(${x}px, ${y + arc}px) scale(${1 + Math.sin(t * Math.PI) * 0.1})`;
        if (t < 1) {
          requestAnimationFrame(tick);
        } else {
          marbleEl.style.transform = '';
          resolve();
        }
      }
      requestAnimationFrame(tick);
    });
  }

  async function animateRemoval(r, c) {
    return new Promise(resolve => {
      const marbleEl = boardEl.querySelector(`.marble[data-r="${r}"][data-c="${c}"]`);
      if (!marbleEl) { resolve(); return; }
      marbleEl.classList.add('removing');
      spawnParticles(r, c);
      setTimeout(resolve, 380);
    });
  }

  // --- Move Execution ---
  async function executeMove(from, over, to) {
    if (animating) return;
    animating = true;

    // Save history
    const snapshot = board.map(row => [...row]);
    history.push({ from, over, to, snapshot, moveCount });

    playSound('jump');

    // Animate jump
    await animateJump(from, to);

    // Update board state
    board[from.r][from.c] = 2;
    board[over.r][over.c] = 2;
    board[to.r][to.c] = 1;

    // Render intermediate state (marble moved, but jumped one still showing for removal anim)
    board[over.r][over.c] = 1; // temporarily restore for rendering
    renderBoard(false);
    board[over.r][over.c] = 2; // set back

    // Animate removal
    playSound('remove');
    await animateRemoval(over.r, over.c);

    moveCount++;
    selected = null;

    renderBoard(false);
    updateStats();
    animating = false;

    // Check game state
    const result = checkWin();
    if (result) {
      setTimeout(() => endGame(result), 400);
    }
  }

  // --- End Game ---
  function endGame(result) {
    const n = countMarbles();
    const modal = document.getElementById('modal');
    const title = document.getElementById('modal-title');
    const msg = document.getElementById('modal-msg');

    if (result === 'perfect') {
      title.textContent = 'Perfect Victory!';
      msg.textContent = `Incredible! You finished with 1 marble in the center in ${moveCount} moves!`;
      playSound('win');
      launchConfetti();
      if (!bestScore || moveCount < bestScore) {
        bestScore = moveCount;
        saveBest(moveCount);
        updateStats();
        msg.textContent += ' New best score!';
      }
    } else if (result === 'win') {
      title.textContent = 'You Won!';
      msg.textContent = `Great job! You finished with 1 marble in ${moveCount} moves. Try to end in the center for a perfect game!`;
      playSound('win');
      launchConfetti();
      if (!bestScore || moveCount < bestScore) {
        bestScore = moveCount;
        saveBest(moveCount);
        updateStats();
        msg.textContent += ' New best score!';
      }
    } else {
      title.textContent = 'No More Moves';
      msg.textContent = `${n} marbles remaining after ${moveCount} moves. The goal is to end with just 1 marble!`;
      playSound('lose');
    }

    modal.classList.add('active');
  }

  function launchConfetti() {
    const colors = ['#d4af37', '#f5e6a3', '#64dcb4', '#4ecdc4', '#ff6b6b', '#c7f464', '#45b7d1', '#f9d56e'];
    for (let i = 0; i < 80; i++) {
      setTimeout(() => {
        const piece = document.createElement('div');
        piece.className = 'confetti-piece';
        piece.style.left = Math.random() * 100 + 'vw';
        piece.style.top = -20 + 'px';
        piece.style.background = colors[Math.floor(Math.random() * colors.length)];
        piece.style.width = (5 + Math.random() * 8) + 'px';
        piece.style.height = (8 + Math.random() * 12) + 'px';
        piece.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
        piece.style.opacity = 0.9;

        const duration = 2000 + Math.random() * 2000;
        const swayAmount = (Math.random() - 0.5) * 200;
        piece.style.animationDuration = duration + 'ms';

        document.body.appendChild(piece);

        piece.animate([
          { transform: `translateY(0) translateX(0) rotate(0deg)`, opacity: 1 },
          { transform: `translateY(105vh) translateX(${swayAmount}px) rotate(${360 + Math.random() * 720}deg)`, opacity: 0 },
        ], { duration, easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)', fill: 'forwards' });

        setTimeout(() => piece.remove(), duration + 100);
      }, i * 30);
    }
  }

  // --- Stats ---
  function updateStats() {
    const n = countMarbles();
    document.getElementById('moves').textContent = moveCount;
    document.getElementById('remaining').textContent = n;
    document.getElementById('best').textContent = bestScore != null ? bestScore : '-';
    document.getElementById('remaining-label').textContent = n + (n === 1 ? ' marble' : ' marbles') + ' on the board';
    document.getElementById('btn-undo').disabled = history.length === 0;
  }

  // --- Event Handling ---
  boardEl.addEventListener('click', (e) => {
    if (animating) return;
    ensureAudio();

    const marbleEl = e.target.closest('.marble');
    const holeEl = e.target.closest('.hole');

    if (marbleEl) {
      const r = parseInt(marbleEl.dataset.r);
      const c = parseInt(marbleEl.dataset.c);

      // If clicking the same marble, deselect
      if (selected && selected.r === r && selected.c === c) {
        selected = null;
        renderBoard(false);
        return;
      }

      // If another marble is selected and this one is a valid jump target... no, marbles can't be targets
      // If a marble is selected and we click another marble, check if it could be a move
      if (selected) {
        // Check if this click could be a jump destination (it can't, it has a marble)
        // So just reselect
        const moves = getValidMoves(r, c);
        if (moves.length > 0) {
          selected = { r, c };
          playSound('select');
          renderBoard(false);
        } else {
          // Try to keep current selection if clicking a marble without moves
          selected = { r, c };
          playSound('select');
          renderBoard(false);
        }
        return;
      }

      // Select this marble if it has valid moves
      selected = { r, c };
      playSound('select');
      renderBoard(false);
      return;
    }

    if (holeEl && selected) {
      const r = parseInt(holeEl.dataset.r);
      const c = parseInt(holeEl.dataset.c);

      // Check if this is a valid move
      const moves = getValidMoves(selected.r, selected.c);
      const move = moves.find(m => m.to.r === r && m.to.c === c);
      if (move) {
        executeMove(move.from, move.over, move.to);
      }
    }
  });

  // Undo
  document.getElementById('btn-undo').addEventListener('click', () => {
    ensureAudio();
    if (animating || history.length === 0) return;
    const prev = history.pop();
    board = prev.snapshot;
    moveCount = prev.moveCount;
    selected = null;
    renderBoard(false);
    updateStats();
  });

  // Restart
  document.getElementById('btn-restart').addEventListener('click', () => {
    ensureAudio();
    document.getElementById('modal').classList.remove('active');
    initBoard();
    renderBoard(true);
  });

  // Modal button
  document.getElementById('modal-btn').addEventListener('click', () => {
    ensureAudio();
    document.getElementById('modal').classList.remove('active');
    initBoard();
    renderBoard(true);
  });

  // Sound toggle
  document.getElementById('btn-sound').addEventListener('click', () => {
    ensureAudio();
    soundEnabled = !soundEnabled;
    document.getElementById('sound-icon').textContent = soundEnabled ? '\u{1F50A}' : '\u{1F507}';
    document.getElementById('sound-lbl').textContent = soundEnabled ? 'On' : 'Off';
  });

  // --- Ambient Particles ---
  function createAmbientParticles() {
    const container = document.getElementById('ambient');
    for (let i = 0; i < 25; i++) {
      const span = document.createElement('span');
      span.style.left = Math.random() * 100 + '%';
      span.style.animationDuration = (8 + Math.random() * 12) + 's';
      span.style.animationDelay = Math.random() * 10 + 's';
      span.style.width = (2 + Math.random() * 3) + 'px';
      span.style.height = span.style.width;
      container.appendChild(span);
    }
  }

  // --- Init ---
  createAmbientParticles();
  initBoard();
  renderBoard(true);
})();
</script>
</body>
</html>
